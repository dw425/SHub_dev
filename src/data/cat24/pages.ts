import { registerPages } from '../pageRegistry'
import type { PageData } from '../pageTypes'

const pages: PageData[] = [
  {
    slug: 'creational',
    badge: 'üè≠ Page 24.1',
    title: 'Creational Patterns',
    description: 'Control how objects are created. These five patterns abstract the instantiation process, making systems independent of how objects are composed and represented‚Äîenabling flexibility without modifying existing code.',
    accentColor: '#14B8A6',
    accentLight: '#2DD4BF',
    metrics: [
      { value: '5', label: 'GoF Patterns' },
      { value: '90%', label: 'Usage in Projects' },
      { value: 'Low', label: 'Complexity' },
      { value: 'High', label: 'Impact' },
    ],
    overview: {
      title: 'Creational Patterns',
      subtitle: '',
      subsections: [
        {
          heading: 'The Five Creational Patterns',
          paragraphs: [
            'Gang of Four\'s object creation patterns',
            'The Gang of Four identified five creational patterns that address different object creation scenarios. Singleton ensures a class has only one instance with global access‚Äîuseful for configuration, logging, or connection pools. Factory Method lets subclasses decide which class to instantiate, enabling framework hooks and plugin systems. Abstract Factory creates families of related objects without specifying concrete classes‚Äîthink cross-platform UI toolkits. Builder separates complex construction from representation, perfect for objects with many optional parameters. Prototype creates objects by cloning existing instances, avoiding costly initialization when objects share most of their state.',
          ],
        },
        {
          heading: 'Factory Pattern Deep Dive',
          paragraphs: [
            'The most commonly used creational pattern',
            'Factory patterns come in three flavors with increasing complexity and flexibility. Simple Factory (not a GoF pattern but widely used) centralizes object creation in a single method that uses conditionals to return different types. Factory Method promotes this to a class hierarchy where each subclass creates its own product type‚Äîthe framework defines the interface, and concrete implementations decide instantiation. Abstract Factory takes this further by creating families of related products, ensuring consistency across product lines. Understanding when to use each variant is crucial: Simple Factory for basic scenarios with few types, Factory Method when you need inheritance-based extension points, and Abstract Factory when products come in coordinated families.',
          ],
        },
        {
          heading: 'Core Concepts',
          paragraphs: [
            'Fundamental ideas underlying creational patterns',
            'Several key concepts underpin all creational patterns. Encapsulation of creation logic means clients don\'t know (or care) which concrete class is instantiated‚Äîthey work with interfaces. Dependency inversion follows naturally: high-level modules depend on abstractions, not concrete implementations. Lazy initialization delays object creation until first use, saving resources. Object pooling reuses expensive objects instead of creating new ones. The registry pattern provides lookup for shared instances without global state. Understanding these concepts helps you apply creational patterns flexibly rather than following rigid recipes.',
          ],
        },
      ],
    },
    concepts: {
      title: 'Key Concepts',
      subtitle: 'Core components and patterns',
      columns: 2,
      cards: [
        {
          className: 'concept-0',
          borderColor: '#3B82F6',
          icon: '1Ô∏è‚É£',
          title: 'Singleton',
          description: 'Ensures a class has only one instance and provides a global point of access to it.',
          examples: [],
        },
        {
          className: 'concept-1',
          borderColor: '#10B981',
          icon: '2Ô∏è‚É£',
          title: 'Factory Method',
          description: 'Define an interface for creating objects, letting subclasses decide which class to instantiate.',
          examples: [],
        },
        {
          className: 'concept-2',
          borderColor: '#8B5CF6',
          icon: '3Ô∏è‚É£',
          title: 'Abstract Factory',
          description: 'Create families of related objects without specifying their concrete classes.',
          examples: [],
        },
        {
          className: 'concept-3',
          borderColor: '#F59E0B',
          icon: '4Ô∏è‚É£',
          title: 'Builder',
          description: 'Separate complex object construction from its representation for different representations.',
          examples: [],
        },
      ],
    },
    hasSvgViz: true,
    algorithms: {
      type: 'card-grid',
      title: 'Pattern Comparison',
      subtitle: 'Evaluating approaches and tools',
      cards: [
        { icon: 'üõ†Ô∏è', title: 'Singleton', subtitle: 'Low', description: 'Need multiple instances later', tags: ['Low'] },
        { icon: 'üõ†Ô∏è', title: 'Factory Method', subtitle: 'Low', description: 'Simple instantiation suffices', tags: ['Low'] },
        { icon: 'üõ†Ô∏è', title: 'Abstract Factory', subtitle: 'Medium', description: 'Products aren\'t related', tags: ['Medium'] },
        { icon: 'üõ†Ô∏è', title: 'Builder', subtitle: 'Low', description: 'Object has few parameters', tags: ['Low'] },
        { icon: 'üõ†Ô∏è', title: 'Prototype', subtitle: 'Medium', description: 'Objects have no shared state', tags: ['Medium'] },
        { icon: 'üìå', title: 'Creational Patterns', subtitle: '', description: 'Control how objects are created. These five patterns abstract the instantiation process, making systems independent of how objects are composed and re', tags: [] },
      ],
    },
    tools: {
      title: 'Language Support',
      subtitle: 'Essential tools and platforms',
      items: [
        { icon: '‚òï', name: 'Java', vendor: '', description: 'Best for: Full pattern implementationEnum Singleton ‚Ä¢ Lombok Builder', tags: [] },
        { icon: 'üêç', name: 'Python', vendor: '', description: 'Best for: Metaclass patternsModule Singleton ‚Ä¢ __new__', tags: [] },
        { icon: 'TS', name: 'TypeScript', vendor: '', description: 'Best for: Interface-based factoriesPartial<T> ‚Ä¢ Generic Factories', tags: [] },
        { icon: 'C#', name: 'C#', vendor: '', description: 'Best for: Generic factoriesLazy<T> ‚Ä¢ Record types', tags: [] },
        { icon: 'Kt', name: 'Kotlin', vendor: '', description: 'Best for: Concise buildersobject Singleton ‚Ä¢ DSL builders', tags: [] },
        { icon: 'ü¶Ä', name: 'Rust', vendor: '', description: 'Best for: Safe patternslazy_static! ‚Ä¢ Builder derive', tags: [] },
        { icon: 'Go', name: 'Go', vendor: '', description: 'Best for: Simple patternssync.Once ‚Ä¢ Functional options', tags: [] },
        { icon: 'üíé', name: 'Ruby', vendor: '', description: 'Best for: DSL buildersClass << self ‚Ä¢ method_missing', tags: [] },
      ],
    },
    bestPractices: {
      title: 'Best Practices',
      subtitle: 'Guidelines and recommendations',
      doItems: [
        'Favor Factory over new() ‚Äî Use factories when you need flexibility in what gets created, but don\'t wrap every instantiation in a factory.',
        'Avoid Singleton When Possible ‚Äî Prefer dependency injection. If you must use Singleton, make it thread-safe and consider testability.',
        'Use Builder for 3+ Parameters ‚Äî When constructors have more than three parameters (especially optional ones), Builder improves readability.',
        'Make Builders Fluent ‚Äî Return \'this\' from setter methods to enable method chaining: builder.setA(a).setB(b).build().',
        'Validate in build() ‚Äî Builder\'s build() method should validate state and throw clear exceptions for invalid configurations.',
        'Implement Deep Clone for Prototype ‚Äî Shallow copies cause subtle bugs. Use serialization or copy constructors for complete cloning.',
        'Return Interfaces from Factories ‚Äî Factory methods should return interface types, not concrete classes, maximizing flexibility.',
        'Use Enums for Singleton in Java ‚Äî Enum singletons are thread-safe, serialization-safe, and protected from reflection attacks.',
        'Consider DI Containers ‚Äî Modern frameworks handle most creation logic. Use patterns for what DI doesn\'t cover.',
        'Document Pattern Usage ‚Äî Name classes clearly (UserFactory, QueryBuilder) and document why the pattern was chosen.',
      ],
      dontItems: [
      ],
    },
    agent: {
      avatar: 'ü§ñ',
      name: 'CreationalPatternEngineer',
      role: '',
      description: 'Expert agent for implementing creational design patterns, refactoring object creation code, and selecting appropriate patterns based on requirements. Specializes in Builder fluent interfaces, thread-safe Singletons, and Factory hierarchies.',
      capabilities: [
        'Builder pattern with validation',
        'Thread-safe Singleton implementations',
        'Factory Method hierarchies',
        'Abstract Factory for product families',
        'Deep clone Prototype patterns',
        'Refactor constructors to patterns',
      ],
      codeFilename: 'user_builder.py',
      code: ``,
    },
    relatedPages: [
      { number: '24.2', title: 'Structural Patterns', description: 'Compose objects into larger structures', slug: 'structural' },
      { number: '24.3', title: 'Behavioral Patterns', description: 'Manage algorithms and communication', slug: 'behavioral' },
      { number: '24.6', title: 'Enterprise Patterns', description: 'Repository, Unit of Work, CQRS', slug: 'enterprise' },
    ],
    prevPage: undefined,
    nextPage: { title: '24.2 Structural Patterns', slug: 'structural' },
  },
  {
    slug: 'structural',
    badge: 'üß± Page 24.2',
    title: 'Structural Patterns',
    description: 'Compose objects and classes into larger structures while keeping them flexible and efficient. These seven patterns enable elegant solutions for interface mismatches, feature extension, and complex hierarchies.',
    accentColor: '#10B981',
    accentLight: '#34D399',
    metrics: [
      { value: '7', label: 'GoF Patterns' },
      { value: '85%', label: 'Usage in Projects' },
      { value: 'Medium', label: 'Complexity' },
      { value: 'High', label: 'Flexibility' },
    ],
    overview: {
      title: 'Structural Patterns',
      subtitle: '',
      subsections: [
        {
          heading: 'The Seven Structural Patterns',
          paragraphs: [
            'Gang of Four\'s object composition patterns',
            'Structural patterns address how classes and objects compose to form larger structures. Adapter converts one interface to another so incompatible classes can work together‚Äîessential for legacy integration. Bridge separates an abstraction from its implementation so both can vary independently‚Äîuseful when you have multiple dimensions of variation. Composite lets you treat individual objects and compositions of objects uniformly‚Äîperfect for tree structures like file systems or UI hierarchies. Decorator adds responsibilities to objects dynamically without subclassing‚Äîthe backbone of stream wrappers and middleware. Facade provides a simplified interface to a complex subsystem‚Äîyour API gateway pattern. Flyweight shares common state among many objects to reduce memory‚Äîused in text editors and game engines. Proxy provides a surrogate to control access to another object‚Äîenabling lazy loading, caching, and remote access.',
          ],
        },
        {
          heading: 'Adapter vs Bridge',
          paragraphs: [
            'Understanding the subtle but critical difference',
            'Adapter and Bridge are frequently confused because both involve abstraction layers between interfaces. The key distinction is intent and timing. Adapter is a retrofit‚Äîyou have two existing interfaces that don\'t match, and you create a converter so they can work together. Bridge is a proactive design decision‚Äîyou anticipate that abstraction and implementation will vary independently, so you separate them from the start. Adapter fixes incompatibility after the fact; Bridge prevents it by design. Think of Adapter as a travel plug converter for your existing devices, while Bridge is designing a universal charging system from day one.',
          ],
        },
        {
          heading: 'Decorator Pattern Deep Dive',
          paragraphs: [
            'Dynamic behavior composition without inheritance explosion',
            'Decorator solves the problem of adding responsibilities to objects dynamically without creating a subclass for every combination. Consider a coffee shop with base drinks (espresso, tea) and add-ons (milk, sugar, whip). With inheritance, you\'d need EspressoWithMilk, EspressoWithSugar, EspressoWithMilkAndSugar, and so on‚Äîan exponential explosion. Decorator lets you wrap objects at runtime: new Whip(new Milk(new Espresso())). Each decorator adds behavior before or after delegating to the wrapped object. This pattern powers Java\'s I/O streams, Python\'s function decorators (@decorator), and middleware pipelines in web frameworks.',
          ],
        },
      ],
    },
    concepts: {
      title: 'Core Concepts',
      subtitle: 'Core components and patterns',
      columns: 2,
      cards: [
        {
          className: 'concept-0',
          borderColor: '#3B82F6',
          icon: 'üîó',
          title: '',
          description: 'Has-a over is-a',
          examples: [],
        },
        {
          className: 'concept-1',
          borderColor: '#10B981',
          icon: 'üì§',
          title: '',
          description: 'Forward to wrapped object',
          examples: [],
        },
        {
          className: 'concept-2',
          borderColor: '#8B5CF6',
          icon: 'üëÅÔ∏è',
          title: '',
          description: 'Same interface as wrapped',
          examples: [],
        },
        {
          className: 'concept-3',
          borderColor: '#F59E0B',
          icon: 'üé≠',
          title: '',
          description: 'Substitute implementations',
          examples: [],
        },
      ],
    },
    hasSvgViz: true,
    algorithms: {
      type: 'table',
      title: 'Pattern Comparison',
      subtitle: 'Evaluating approaches and tools',
      headers: ['Name', 'Category', 'Best For', 'Complexity', 'Rating'],
      rows: [
        { icon: 'üõ†Ô∏è', name: 'Adapter', tagText: 'Interface conversion', tagClass: 'tag-blue', bestFor: 'Legacy integration', complexity: 'medium', rating: 'Low' },
        { icon: 'üõ†Ô∏è', name: 'Bridge', tagText: 'Decouple abstraction', tagClass: 'tag-green', bestFor: 'Independent variation', complexity: 'medium', rating: 'Medium' },
        { icon: 'üõ†Ô∏è', name: 'Composite', tagText: 'Tree structures', tagClass: 'tag-purple', bestFor: 'Uniform hierarchies', complexity: 'medium', rating: 'Medium' },
        { icon: 'üõ†Ô∏è', name: 'Decorator', tagText: 'Dynamic behavior', tagClass: 'tag-orange', bestFor: 'Runtime extension', complexity: 'medium', rating: 'Medium' },
        { icon: 'üõ†Ô∏è', name: 'Facade', tagText: 'Simplify interface', tagClass: 'tag-pink', bestFor: 'Hide complexity', complexity: 'medium', rating: 'Low' },
        { icon: 'üõ†Ô∏è', name: 'Flyweight', tagText: 'Share state', tagClass: 'tag-blue', bestFor: 'Memory efficiency', complexity: 'medium', rating: 'High' },
        { icon: 'üõ†Ô∏è', name: 'Proxy', tagText: 'Control access', tagClass: 'tag-green', bestFor: 'Lazy/remote/secure', complexity: 'medium', rating: 'Medium' },
      ],
    },
    tools: {
      title: 'Tools & Frameworks',
      subtitle: 'Essential tools and platforms',
      items: [
      ],
    },
    bestPractices: {
      title: 'Best Practices',
      subtitle: 'Guidelines and recommendations',
      doItems: [
        'Prefer Composition to Inheritance ‚Äî Structural patterns shine with composition. Inheritance creates tight coupling; composition enables flexibility.',
        'Keep Decorator Stacks Shallow ‚Äî Limit to 2-3 decorators deep. Document stacking order. Consider if middleware pattern fits better.',
        'Use Facade for Module Boundaries ‚Äî Every complex subsystem should expose a Facade. It\'s your API contract‚Äîkeep it stable.',
        'Adapter for Third-Party Only ‚Äî Use Adapter to wrap external libraries. For internal code, fix the interface at the source.',
        'Bridge When You See 2x2 Matrix ‚Äî If you have two dimensions of variation (e.g., shapes √ó renderers), Bridge prevents class explosion.',
        'Make Proxy Costs Visible ‚Äî Remote and lazy proxies introduce latency. Consider explicit async APIs instead of transparent proxies.',
        'Composite for Natural Hierarchies ‚Äî File systems, UI trees, org charts‚ÄîComposite excels. Don\'t force flat structures into hierarchies.',
        'Flyweight Only for Proven Memory Issues ‚Äî Profile first. Flyweight adds complexity; use it only when memory is demonstrably a problem.',
        'Same Interface Throughout Chain ‚Äî Decorators and proxies must implement the same interface as their target. This enables transparency.',
        'Document Wrapping Relationships ‚Äî Make it clear which classes wrap which. UML diagrams help; so do clear naming conventions.',
      ],
      dontItems: [
      ],
    },
    agent: {
      avatar: 'ü§ñ',
      name: 'StructuralPatternEngineer',
      role: '',
      description: 'Expert agent for implementing structural design patterns, composing objects into flexible structures, and refactoring inheritance hierarchies to composition. Specializes in Decorator chains, Adapter wrappers, and Facade interfaces.',
      capabilities: [
        'Decorator chains with proper ordering',
        'Adapter wrappers for legacy integration',
        'Facade interfaces for complex subsystems',
        'Composite hierarchies for tree structures',
        'Bridge separation of abstraction/implementation',
        'Proxy implementations for access control',
      ],
      codeFilename: 'decorator_example.py',
      code: ``,
    },
    relatedPages: [
      { number: '24.1', title: 'Creational Patterns', description: 'Factory, Singleton, Builder patterns', slug: 'creational' },
      { number: '24.3', title: 'Behavioral Patterns', description: 'Observer, Strategy, Command patterns', slug: 'behavioral' },
      { number: '24.4', title: 'Architectural Patterns', description: 'MVC, MVVM, Clean Architecture', slug: 'architectural' },
    ],
    prevPage: { title: '24.1 Creational Patterns', slug: 'creational' },
    nextPage: { title: '24.3 Behavioral Patterns', slug: 'behavioral' },
  },
  {
    slug: 'behavioral',
    badge: 'üé≠ Page 24.3',
    title: 'Behavioral Patterns',
    description: 'Define how objects communicate and distribute responsibility. These eleven patterns manage algorithms, relationships, and responsibilities between objects‚Äîenabling flexible, maintainable interactions.',
    accentColor: '#8B5CF6',
    accentLight: '#A78BFA',
    metrics: [
      { value: '11', label: 'GoF Patterns' },
      { value: '95%', label: 'Usage in Projects' },
      { value: 'Medium', label: 'Complexity' },
      { value: 'Critical', label: 'For Maintainability' },
    ],
    overview: {
      title: 'Behavioral Patterns',
      subtitle: '',
      subsections: [
        {
          heading: 'The Eleven Behavioral Patterns',
          paragraphs: [
            'Gang of Four\'s communication and responsibility patterns',
            'Behavioral patterns focus on algorithms and the assignment of responsibilities between objects. Observer establishes a one-to-many dependency so when one object changes, all dependents are notified‚Äîthe backbone of reactive programming and event systems. Strategy encapsulates interchangeable algorithms, letting clients choose at runtime without conditionals. Command turns requests into objects, enabling queuing, logging, and undo operations. State allows objects to alter behavior when internal state changes‚Äîcleaner than switch statements. Iterator provides sequential access to collections without exposing structure. Chain of Responsibility passes requests along a chain until one handler processes it. Template Method defines algorithm skeletons with customizable steps. Mediator centralizes complex communications. Memento captures and restores object state. Visitor adds operations to object structures without modification. Interpreter builds grammar representations for specialized languages.',
          ],
        },
        {
          heading: 'Observer Pattern Deep Dive',
          paragraphs: [
            'The foundation of reactive and event-driven programming',
            'Observer is arguably the most important behavioral pattern, forming the basis of event systems, reactive programming, and data binding frameworks. The pattern establishes a one-to-many relationship: when a Subject changes state, all registered Observers are automatically notified. This decouples the subject from its dependents‚Äîit doesn\'t need to know who\'s listening or what they\'ll do with the notification. Modern implementations include RxJS Observables, Vue\'s reactivity system, and the DOM\'s addEventListener. The key challenge is lifecycle management: observers that aren\'t properly unsubscribed create memory leaks, keeping both the observer and subject alive indefinitely.',
          ],
        },
        {
          heading: 'Strategy vs State',
          paragraphs: [
            'Similar structure, different intent',
            'Strategy and State have nearly identical class structures but fundamentally different purposes. Strategy encapsulates algorithms that a client explicitly chooses‚Äîthink payment methods, compression algorithms, or sorting strategies. The client knows about alternatives and selects one. State encapsulates behaviors that change automatically based on internal conditions‚Äîthink order status, connection state, or game modes. The object manages its own transitions; clients interact with a consistent interface unaware of internal state. Strategy is "choose your algorithm"; State is "behavior changes automatically." If you\'re writing switch statements to choose behavior, you need Strategy. If you\'re writing switch statements that check current state, you need State.',
          ],
        },
      ],
    },
    concepts: {
      title: 'Key Concepts',
      subtitle: 'Core components and patterns',
      columns: 2,
      cards: [
        {
          className: 'concept-0',
          borderColor: '#3B82F6',
          icon: 'üëÅÔ∏è',
          title: 'Observer',
          description: 'One-to-many dependency for automatic notification when state changes.',
          examples: [],
        },
        {
          className: 'concept-1',
          borderColor: '#10B981',
          icon: 'üéØ',
          title: 'Strategy',
          description: 'Encapsulate algorithms and make them interchangeable at runtime.',
          examples: [],
        },
        {
          className: 'concept-2',
          borderColor: '#8B5CF6',
          icon: 'üìú',
          title: 'Command',
          description: 'Encapsulate requests as objects for queuing, logging, undo.',
          examples: [],
        },
        {
          className: 'concept-3',
          borderColor: '#F59E0B',
          icon: 'üîÑ',
          title: 'State',
          description: 'Alter behavior when internal state changes; appear to change class.',
          examples: [],
        },
      ],
    },
    hasSvgViz: true,
    algorithms: {
      type: 'card-grid',
      title: 'Pattern Comparison',
      subtitle: 'Evaluating approaches and tools',
      cards: [
        { icon: 'üõ†Ô∏è', title: 'Observer', subtitle: 'Event notification', description: 'Reactive updates', tags: ['Event notification'] },
        { icon: 'üõ†Ô∏è', title: 'Strategy', subtitle: 'Algorithm selection', description: 'Runtime flexibility', tags: ['Algorithm selection'] },
        { icon: 'üõ†Ô∏è', title: 'Command', subtitle: 'Request encapsulation', description: 'Undo/redo, queuing', tags: ['Request encapsulation'] },
        { icon: 'üõ†Ô∏è', title: 'State', subtitle: 'State-dependent behavior', description: 'Clean state machines', tags: ['State-dependent behavior'] },
        { icon: 'üõ†Ô∏è', title: 'Chain of Resp.', subtitle: 'Handler pipeline', description: 'Flexible processing', tags: ['Handler pipeline'] },
        { icon: 'üõ†Ô∏è', title: 'Iterator', subtitle: 'Collection traversal', description: 'Uniform access', tags: ['Collection traversal'] },
        { icon: 'üõ†Ô∏è', title: 'Template Method', subtitle: 'Algorithm skeleton', description: 'Framework hooks', tags: ['Algorithm skeleton'] },
        { icon: 'üõ†Ô∏è', title: 'Visitor', subtitle: 'External operations', description: 'Add ops without modify', tags: ['External operations'] },
      ],
    },
    tools: {
      title: 'Tools & Frameworks',
      subtitle: 'Essential tools and platforms',
      items: [
      ],
    },
    bestPractices: {
      title: 'Best Practices',
      subtitle: 'Guidelines and recommendations',
      doItems: [
        'Always Unsubscribe Observers ‚Äî Memory leaks from forgotten subscriptions are the #1 Observer bug. Use lifecycle hooks or weak references.',
        'Keep Strategies Stateless ‚Äî Strategies that hold state become hard to swap. Pass context as parameters instead.',
        'Commands Should Be Reversible ‚Äî If you need undo, design commands with execute() and undo() from the start. Retrofitting is painful.',
        'States Own Their Transitions ‚Äî Let state objects decide when and where to transition. Context should just delegate to current state.',
        'Log Chain of Responsibility ‚Äî When requests pass through handlers silently, debugging is hard. Log at each handler for visibility.',
        'Prefer Strategy Over Conditionals ‚Äî When you see switch on type or repeated if-else chains, extract a Strategy interface.',
        'Use Iterator for Custom Collections ‚Äî Implement Iterator protocol so your collections work with for-of loops and spread operators.',
        'Template Method for Frameworks ‚Äî Define the skeleton, let users override hooks. This is how frameworks achieve extensibility.',
        'Mediator Shouldn\'t Become God Object ‚Äî Mediator coordinates but shouldn\'t contain business logic. Keep it thin and focused on routing.',
        'Visitor for Stable Structures Only ‚Äî Adding new element types requires changing all visitors. Use only when structure is stable but operations change.',
      ],
      dontItems: [
      ],
    },
    agent: {
      avatar: 'ü§ñ',
      name: 'BehavioralPatternEngineer',
      role: '',
      description: 'Expert agent for implementing behavioral design patterns, refactoring complex conditionals, and designing event-driven systems. Specializes in Observer subscriptions, State machines, and Strategy selection with proper lifecycle management.',
      capabilities: [
        'Observer with proper unsubscription',
        'Strategy pattern refactoring',
        'State machine implementation',
        'Command with undo/redo',
        'Chain of Responsibility pipelines',
        'Mediator for complex coordination',
      ],
      codeFilename: 'observer_example.py',
      code: ``,
    },
    relatedPages: [
      { number: '24.2', title: 'Structural Patterns', description: 'Adapter, Decorator, Facade patterns', slug: 'structural' },
      { number: '24.4', title: 'Architectural Patterns', description: 'MVC, MVVM, Clean Architecture', slug: 'architectural' },
      { number: '24.5', title: 'Concurrency Patterns', description: 'Thread pools, async patterns', slug: 'concurrency' },
    ],
    prevPage: { title: '24.2 Structural Patterns', slug: 'structural' },
    nextPage: { title: '24.4 Architectural Patterns', slug: 'architectural' },
  },
  {
    slug: 'architectural',
    badge: 'üèõÔ∏è Page 24.4',
    title: 'Architectural Patterns',
    description: 'Define the fundamental structural organization of software systems. These high-level patterns establish how components interact, where logic lives, and how systems scale‚Äîdecisions that shape everything built on top.',
    accentColor: '#F59E0B',
    accentLight: '#FBBF24',
    metrics: [
      { value: '7+', label: 'Major Patterns' },
      { value: '100%', label: 'Enterprise Usage' },
      { value: 'High', label: 'Complexity' },
      { value: 'Critical', label: 'Long-term Impact' },
    ],
    overview: {
      title: 'Architectural Patterns',
      subtitle: '',
      subsections: [
        {
          heading: 'Major Architectural Patterns',
          paragraphs: [
            'High-level structures that shape entire systems',
            'Architectural patterns operate at a higher level than GoF patterns, defining how entire applications or systems are structured. MVC (Model-View-Controller) separates data, presentation, and user input handling‚Äîthe foundation of web frameworks for decades. MVVM (Model-View-ViewModel) adds data binding for reactive UIs. MVP (Model-View-Presenter) gives the presenter full control over the view. Clean Architecture places business rules at the center with dependencies pointing inward. Hexagonal Architecture (Ports & Adapters) isolates core logic from external concerns through explicit interfaces. Layered Architecture stacks presentation, business, and data access tiers. Onion Architecture is similar to Clean but emphasizes domain model centrality. These patterns share a common goal: isolating what matters most (business logic) from what changes frequently (UI, databases, external services).',
          ],
        },
        {
          heading: 'The MVC Family',
          paragraphs: [
            'MVC, MVP, and MVVM are variations on separating presentation from logic, each optimized for different scenarios. MVC originated in Smalltalk and powers most web frameworks: the Controller handles user input, updates the Model, and selects a View. MVP emerged for desktop applications where the View needed to be more passive‚Äîthe Presenter contains all presentation logic and directly manipulates the View. MVVM evolved for frameworks with rich data binding: the ViewModel exposes observable properties that the View binds to automatically, eliminating manual UI updates. Choose MVC for traditional web apps, MVP when you need testable presentation logic with passive views, and MVVM when your framework provides robust data binding.',
          ],
        },
        {
          heading: 'Clean Architecture',
          paragraphs: [
            'Dependencies point inward, business rules at center',
            'Clean Architecture, popularized by Robert C. Martin (Uncle Bob), organizes code in concentric circles with the Dependency Rule: source code dependencies can only point inward. The innermost circle contains Entities‚Äîenterprise business rules that are the most stable. The next circle holds Use Cases‚Äîapplication-specific business rules that orchestrate data flow. Interface Adapters (Controllers, Presenters, Gateways) convert data between use cases and external agents. The outermost circle contains Frameworks and Drivers‚Äîthe web, databases, UI frameworks‚Äîthe most volatile and easily replaced components. This structure ensures business rules never depend on frameworks, making the core testable, maintainable, and technology-independent.',
          ],
        },
      ],
    },
    concepts: {
      title: 'Key Concepts',
      subtitle: 'Core components and patterns',
      columns: 2,
      cards: [
        {
          className: 'concept-0',
          borderColor: '#3B82F6',
          icon: 'üî∫',
          title: 'MVC',
          description: 'Separates data (Model), presentation (View), and user input (Controller).',
          examples: [],
        },
        {
          className: 'concept-1',
          borderColor: '#10B981',
          icon: 'üîó',
          title: 'MVVM',
          description: 'ViewModel exposes data and commands; View binds automatically via data binding.',
          examples: [],
        },
        {
          className: 'concept-2',
          borderColor: '#8B5CF6',
          icon: 'üéØ',
          title: 'MVP',
          description: 'Presenter handles all logic; View is passive and only displays what it\'s told.',
          examples: [],
        },
        {
          className: 'concept-3',
          borderColor: '#F59E0B',
          icon: 'üßÖ',
          title: 'Clean Architecture',
          description: 'Dependencies point inward; business rules at center, frameworks at edges.',
          examples: [],
        },
      ],
    },
    hasSvgViz: true,
    algorithms: {
      type: 'table',
      title: 'Pattern Comparison',
      subtitle: 'Evaluating approaches and tools',
      headers: ['Name', 'Category', 'Best For', 'Complexity', 'Rating'],
      rows: [
        { icon: 'üõ†Ô∏è', name: 'MVC', tagText: 'Web applications', tagClass: 'tag-blue', bestFor: 'Simple but views can get fat', complexity: 'medium', rating: 'Low' },
        { icon: 'üõ†Ô∏è', name: 'MVVM', tagText: 'Rich client apps', tagClass: 'tag-green', bestFor: 'Requires data binding framework', complexity: 'medium', rating: 'Medium' },
        { icon: 'üõ†Ô∏è', name: 'MVP', tagText: 'Testable UI', tagClass: 'tag-purple', bestFor: 'More boilerplate than MVC', complexity: 'medium', rating: 'Medium' },
        { icon: 'üõ†Ô∏è', name: 'Clean', tagText: 'Complex domains', tagClass: 'tag-orange', bestFor: 'Significant upfront investment', complexity: 'medium', rating: 'High' },
        { icon: 'üõ†Ô∏è', name: 'Hexagonal', tagText: 'Ports & Adapters', tagClass: 'tag-pink', bestFor: 'Many interfaces to define', complexity: 'medium', rating: 'High' },
        { icon: 'üõ†Ô∏è', name: 'Layered', tagText: 'Simple enterprise', tagClass: 'tag-blue', bestFor: 'Layers can become coupled', complexity: 'medium', rating: 'Low' },
        { icon: 'üõ†Ô∏è', name: 'Event-Driven', tagText: 'Scalable systems', tagClass: 'tag-green', bestFor: 'Debugging distributed events', complexity: 'medium', rating: 'High' },
      ],
    },
    tools: {
      title: 'Tools & Frameworks',
      subtitle: 'Essential tools and platforms',
      items: [
      ],
    },
    bestPractices: {
      title: 'Best Practices',
      subtitle: 'Guidelines and recommendations',
      doItems: [
        'Start Simple, Evolve ‚Äî Begin with layered architecture. Add complexity (Clean, Hexagonal) only when the domain justifies it.',
        'Enforce Boundaries ‚Äî Use module systems, linting rules, or architectural tests (ArchUnit) to prevent boundary violations.',
        'Keep Business Logic Pure ‚Äî Use cases and entities should have zero framework imports. If they do, refactor immediately.',
        'Design for Testability ‚Äî If unit testing requires databases or HTTP, your architecture is wrong. Inject dependencies, use ports.',
        'Document Decisions (ADRs) ‚Äî Architecture Decision Records capture why you chose patterns. Future you will thank present you.',
        'Delay Framework Decisions ‚Äî Choose database, web framework, ORM as late as possible. Design core logic first.',
        'Vertical Slices Over Layers ‚Äî Consider organizing by feature (user/, order/) rather than technical layer (controllers/, services/).',
        'Don\'t Share Database Tables ‚Äî In microservices or modular monoliths, each module owns its data. No shared tables between boundaries.',
        'Make Dependencies Explicit ‚Äî Constructor injection over service locators. Dependencies should be visible in signatures.',
        'Review Architecture Regularly ‚Äî Hold architecture reviews. Patterns that fit yesterday may not fit today\'s scale or requirements.',
      ],
      dontItems: [
      ],
    },
    agent: {
      avatar: 'ü§ñ',
      name: 'ArchitectureEngineer',
      role: '',
      description: 'Expert agent for designing system architecture, reviewing existing structures, and recommending patterns based on requirements. Specializes in Clean Architecture implementation, dependency analysis, and modular design with clear boundaries.',
      capabilities: [
        'Clean Architecture scaffolding',
        'Hexagonal ports and adapters',
        'Dependency analysis and visualization',
        'MVC/MVVM structure setup',
        'Architecture Decision Records',
        'Boundary violation detection',
      ],
      codeFilename: 'clean_architecture/',
      code: ``,
    },
    relatedPages: [
      { number: '24.3', title: 'Behavioral Patterns', description: 'Observer, Strategy, Command patterns', slug: 'behavioral' },
      { number: '24.5', title: 'Concurrency Patterns', description: 'Thread pools, async, reactive patterns', slug: 'concurrency' },
      { number: '24.6', title: 'Enterprise Patterns', description: 'Repository, CQRS, Event Sourcing', slug: 'enterprise' },
    ],
    prevPage: { title: '24.3 Behavioral Patterns', slug: 'behavioral' },
    nextPage: { title: '24.5 Concurrency Patterns', slug: 'concurrency' },
  },
  {
    slug: 'concurrency',
    badge: '‚ö° Page 24.5',
    title: 'Concurrency Patterns',
    description: 'Manage parallel execution, shared resources, and asynchronous operations safely. These patterns prevent race conditions, coordinate threads, and maximize throughput without sacrificing correctness.',
    accentColor: '#EC4899',
    accentLight: '#F472B6',
    metrics: [
      { value: '12+', label: 'Core Patterns' },
      { value: 'Essential', label: 'For Modern Apps' },
      { value: 'High', label: 'Complexity' },
      { value: '10-100x', label: 'Performance Gain' },
    ],
    overview: {
      title: 'Concurrency Patterns',
      subtitle: '',
      subsections: [
        {
          heading: 'Concurrency Patterns',
          paragraphs: [
            'Managing parallel execution and shared resources',
            'Concurrency patterns address the fundamental challenges of parallel execution: how to share data safely, coordinate independent activities, and maximize throughput. Thread Pool manages a collection of reusable threads, avoiding the overhead of constant thread creation. Producer-Consumer decouples data generation from processing via queues. Actor Model encapsulates state within actors that communicate only via messages‚Äîno shared memory. Reactor handles many connections with few threads using event-driven I/O. Monitor Object synchronizes method calls on an object. Read-Write Lock allows multiple readers or one writer. Future/Promise represents a value that will be available later. Semaphore limits concurrent access to resources. Barrier synchronizes multiple threads at a checkpoint. These patterns range from low-level primitives to high-level architectural approaches.',
          ],
        },
        {
          heading: 'Thread Pool Pattern',
          paragraphs: [
            'Reusable threads for efficient task execution',
            'Thread Pool is the workhorse of concurrent programming. Creating threads is expensive‚Äîeach requires memory allocation, OS resources, and context switching overhead. A thread pool pre-creates a fixed number of worker threads that wait for tasks. When tasks arrive, available workers execute them. When done, workers return to the pool rather than terminating. This amortizes creation cost across many tasks and prevents resource exhaustion from unbounded thread creation. Most web servers, application servers, and async frameworks use thread pools internally. Key decisions include pool size (often CPU cores for compute-bound, larger for I/O-bound), queue strategy (bounded vs unbounded), and rejection policy (what happens when the pool is saturated).',
          ],
        },
        {
          heading: 'Async/Await Pattern',
          paragraphs: [
            'Non-blocking operations with synchronous-style code',
            'Async/await revolutionized how we write concurrent code by making asynchronous operations look synchronous. Traditional callbacks led to "callback hell"‚Äîdeeply nested code that\'s hard to read and debug. Promises improved this with chaining, but async/await goes further. When you await an async operation, the runtime suspends the current function, frees the thread to do other work, and resumes when the result is ready. The code reads top-to-bottom like synchronous code, but executes non-blocking. Under the hood, compilers transform async functions into state machines. This pattern dominates modern JavaScript, Python, C#, Rust, and Kotlin. The key insight: don\'t block threads waiting for I/O; let them handle other work.',
          ],
        },
      ],
    },
    concepts: {
      title: 'Key Concepts',
      subtitle: 'Core components and patterns',
      columns: 2,
      cards: [
        {
          className: 'concept-0',
          borderColor: '#3B82F6',
          icon: 'üèä',
          title: 'Thread Pool',
          description: 'Pre-created threads execute tasks from a queue; avoids creation overhead.',
          examples: [],
        },
        {
          className: 'concept-1',
          borderColor: '#10B981',
          icon: 'üì¶',
          title: 'Producer-Consumer',
          description: 'Producers add to queue; consumers process independently at their own pace.',
          examples: [],
        },
        {
          className: 'concept-2',
          borderColor: '#8B5CF6',
          icon: 'üé≠',
          title: 'Actor Model',
          description: 'Isolated actors communicate via async messages; no shared state.',
          examples: [],
        },
        {
          className: 'concept-3',
          borderColor: '#F59E0B',
          icon: '‚ö°',
          title: 'Reactor',
          description: 'Single thread handles many connections via non-blocking I/O and callbacks.',
          examples: [],
        },
      ],
    },
    hasSvgViz: true,
    algorithms: {
      type: 'card-grid',
      title: 'Pattern Comparison',
      subtitle: 'Evaluating approaches and tools',
      cards: [
        { icon: 'üõ†Ô∏è', title: 'Thread Pool', subtitle: 'Infrastructure', description: 'CPU-bound tasks', tags: ['Infrastructure'] },
        { icon: 'üõ†Ô∏è', title: 'Async/Await', subtitle: 'Language feature', description: 'I/O-bound tasks', tags: ['Language feature'] },
        { icon: 'üõ†Ô∏è', title: 'Actor Model', subtitle: 'Architecture', description: 'Distributed systems', tags: ['Architecture'] },
        { icon: 'üõ†Ô∏è', title: 'Producer-Consumer', subtitle: 'Architecture', description: 'Work pipelines', tags: ['Architecture'] },
        { icon: 'üõ†Ô∏è', title: 'Reactor', subtitle: 'Infrastructure', description: 'High connection count', tags: ['Infrastructure'] },
        { icon: 'üõ†Ô∏è', title: 'Read-Write Lock', subtitle: 'Primitive', description: 'Read-heavy workloads', tags: ['Primitive'] },
        { icon: 'üõ†Ô∏è', title: 'Semaphore', subtitle: 'Primitive', description: 'Resource limiting', tags: ['Primitive'] },
      ],
    },
    tools: {
      title: 'Tools & Frameworks',
      subtitle: 'Essential tools and platforms',
      items: [
      ],
    },
    bestPractices: {
      title: 'Best Practices',
      subtitle: 'Guidelines and recommendations',
      doItems: [
        'Prefer Immutability ‚Äî Immutable data eliminates race conditions entirely. Copy-on-write, persistent data structures, final/const.',
        'Minimize Shared State ‚Äî Each piece of shared mutable state is a bug waiting to happen. Isolate state within threads/actors.',
        'Use High-Level Constructs ‚Äî async/await over threads, actors over locks, channels over shared memory. Let experts handle the hard parts.',
        'Lock in Consistent Order ‚Äî Always acquire locks A then B, never B then A. Document lock ordering. Prevents deadlocks.',
        'Keep Critical Sections Small ‚Äî Hold locks for minimum time. Do computation outside locks, only lock for the actual shared access.',
        'Use Thread-Safe Collections ‚Äî ConcurrentHashMap, BlockingQueue, etc. Don\'t synchronize manually what libraries do better.',
        'Don\'t Assume Atomicity ‚Äî i++ is not atomic. Check is not thread-safe. Use explicit atomic types or synchronization.',
        'Test Under Load ‚Äî Concurrency bugs hide until stressed. Use load testing, fuzzing, and race detectors (TSan, Helgrind).',
        'Avoid Blocking in Async Code ‚Äî Don\'t call blocking APIs from async contexts. It defeats the purpose and causes thread starvation.',
        'Document Thread Safety ‚Äî Mark classes/methods as thread-safe or not. Future maintainers (including you) will thank you.',
      ],
      dontItems: [
      ],
    },
    agent: {
      avatar: 'ü§ñ',
      name: 'ConcurrencyEngineer',
      role: '',
      description: 'Expert agent for designing thread-safe systems, implementing async patterns, and debugging race conditions. Specializes in identifying concurrency bottlenecks, choosing appropriate synchronization primitives, and refactoring blocking code to async.',
      capabilities: [
        'Thread pool sizing and tuning',
        'Async/await refactoring',
        'Lock analysis and optimization',
        'Race condition detection',
        'Producer-consumer design',
        'Actor model implementation',
      ],
      codeFilename: 'async_example.py',
      code: ``,
    },
    relatedPages: [
      { number: '24.3', title: 'Behavioral Patterns', description: 'Observer, Strategy, Command patterns', slug: 'behavioral' },
      { number: '24.4', title: 'Architectural Patterns', description: 'MVC, Clean Architecture, Hexagonal', slug: 'architectural' },
      { number: '24.6', title: 'Enterprise Patterns', description: 'Repository, CQRS, Event Sourcing', slug: 'enterprise' },
    ],
    prevPage: { title: '24.4 Architectural Patterns', slug: 'architectural' },
    nextPage: { title: '24.6 Enterprise Patterns', slug: 'enterprise' },
  },
  {
    slug: 'enterprise',
    badge: 'üè¢ Page 24.6',
    title: 'Enterprise Patterns',
    description: 'Solve recurring problems in large-scale business applications. These patterns manage data access, handle complex transactions, and structure domain logic for systems that serve thousands of users.',
    accentColor: '#06B6D4',
    accentLight: '#22D3EE',
    metrics: [
      { value: '15+', label: 'Core Patterns' },
      { value: 'Essential', label: 'For Business Apps' },
      { value: 'Medium', label: 'Complexity' },
      { value: '30+ Years', label: 'Battle-Tested' },
    ],
    overview: {
      title: 'Enterprise Patterns',
      subtitle: '',
      subsections: [
        {
          heading: 'Enterprise Application Patterns',
          paragraphs: [
            'Proven solutions from Patterns of Enterprise Application Architecture',
            'Enterprise patterns emerged from decades of building business applications at scale. Martin Fowler\'s "Patterns of Enterprise Application Architecture" codified solutions that countless teams had discovered independently. Repository provides collection-like access to domain objects while hiding persistence details. Unit of Work tracks changes to multiple objects and commits them in a single transaction. Service Layer defines application boundaries and coordinates domain operations. Domain Model encapsulates business logic in rich objects rather than procedural scripts. Data Transfer Object (DTO) carries data between processes or layers. CQRS (Command Query Responsibility Segregation) separates reads from writes for independent scaling. Event Sourcing stores state changes as a sequence of events rather than current state.',
          ],
        },
        {
          heading: 'Repository Pattern',
          paragraphs: [
            'Collection-like interface for domain object access',
            'Repository is arguably the most widely used enterprise pattern. It encapsulates the logic required to access data sources, providing a collection-like interface for domain objects. Application code works with repositories using domain terms (findByEmail, getActiveUsers) rather than database queries. This abstraction enables unit testing with mock repositories and allows swapping persistence mechanisms without changing business logic. The pattern works seamlessly with Unit of Work to track changes. Common implementations provide generic base classes (Repository<T>) with domain-specific extensions. Key insight: repositories work with aggregate roots, not arbitrary entities‚Äîeach aggregate has its own repository.',
          ],
        },
        {
          heading: 'CQRS & Event Sourcing',
          paragraphs: [
            'Separate reads from writes; store events as truth',
            'CQRS and Event Sourcing are often used together but serve different purposes. CQRS recognizes that reads and writes have different characteristics: reads are frequent and need fast, denormalized data; writes are less frequent but need strong consistency and validation. By separating models, each can be optimized independently‚Äîread models can be denormalized views, write models can focus on business rules. Event Sourcing changes how we persist state: instead of storing current values, we store the sequence of events that led to current state. "UserCreated", "AddressChanged", "OrderPlaced" become the source of truth. This enables complete audit trails, temporal queries ("what was the state on March 15th?"), and event replay for debugging or rebuilding read models.',
          ],
        },
      ],
    },
    concepts: {
      title: 'Key Concepts',
      subtitle: 'Core components and patterns',
      columns: 2,
      cards: [
        {
          className: 'concept-0',
          borderColor: '#3B82F6',
          icon: 'üì¶',
          title: 'Repository',
          description: 'Mediates between domain and data mapping; collection-like interface for accessing objects.',
          examples: [],
        },
        {
          className: 'concept-1',
          borderColor: '#10B981',
          icon: 'üîÑ',
          title: 'Unit of Work',
          description: 'Tracks object changes and coordinates writing them to database in single transaction.',
          examples: [],
        },
        {
          className: 'concept-2',
          borderColor: '#8B5CF6',
          icon: 'üéØ',
          title: 'Service Layer',
          description: 'Defines application\'s boundary with a layer of services that coordinates responses.',
          examples: [],
        },
        {
          className: 'concept-3',
          borderColor: '#F59E0B',
          icon: 'üß†',
          title: 'Domain Model',
          description: 'Object model of the domain with both behavior and data in domain objects.',
          examples: [],
        },
      ],
    },
    hasSvgViz: true,
    algorithms: {
      type: 'table',
      title: 'Pattern Comparison',
      subtitle: 'Evaluating approaches and tools',
      headers: ['Name', 'Category', 'Best For', 'Complexity', 'Rating'],
      rows: [
        { icon: 'üõ†Ô∏è', name: 'Repository', tagText: 'Data access abstraction', tagClass: 'tag-blue', bestFor: 'Unit of Work', complexity: 'medium', rating: 'Low' },
        { icon: 'üõ†Ô∏è', name: 'Unit of Work', tagText: 'Transaction coordination', tagClass: 'tag-green', bestFor: 'Repository', complexity: 'medium', rating: 'Low' },
        { icon: 'üõ†Ô∏è', name: 'Service Layer', tagText: 'Application boundary', tagClass: 'tag-purple', bestFor: 'Domain Model', complexity: 'medium', rating: 'Low' },
        { icon: 'üõ†Ô∏è', name: 'Domain Model', tagText: 'Business logic home', tagClass: 'tag-orange', bestFor: 'Repository', complexity: 'medium', rating: 'Medium' },
        { icon: 'üõ†Ô∏è', name: 'CQRS', tagText: 'Read/write separation', tagClass: 'tag-pink', bestFor: 'Event Sourcing', complexity: 'medium', rating: 'Medium' },
        { icon: 'üõ†Ô∏è', name: 'Event Sourcing', tagText: 'Event-based persistence', tagClass: 'tag-blue', bestFor: 'CQRS', complexity: 'medium', rating: 'High' },
        { icon: 'üõ†Ô∏è', name: 'DTO', tagText: 'Cross-boundary data', tagClass: 'tag-green', bestFor: 'Service Layer', complexity: 'medium', rating: 'Low' },
      ],
    },
    tools: {
      title: 'Tools & Frameworks',
      subtitle: 'Essential tools and platforms',
      items: [
      ],
    },
    bestPractices: {
      title: 'Best Practices',
      subtitle: 'Guidelines and recommendations',
      doItems: [
        'Repository Per Aggregate ‚Äî One repository per aggregate root. Don\'t create repositories for every entity‚Äîonly aggregate roots get repositories.',
        'Request-Scoped Unit of Work ‚Äî In web apps, scope Unit of Work to HTTP request. Commit at end of successful request, rollback on errors.',
        'Thin Service Layer ‚Äî Services orchestrate; domain objects contain logic. If services are fat with if-else, refactor to domain model.',
        'Use Case Specific DTOs ‚Äî Create DTOs for specific use cases. UserSummaryDTO, UserDetailDTO, not generic UserDTO with optional fields.',
        'Event Schema Evolution ‚Äî Plan for event versioning from day one. Events are immutable; use upcasters to transform old events to new schemas.',
        'Separate Read Models ‚Äî In CQRS, build read models optimized for queries. Denormalize aggressively‚Äîstorage is cheap, joins are not.',
        'Domain Events for Side Effects ‚Äî Use domain events to trigger side effects (notifications, integrations) instead of direct calls in services.',
        'Specification Pattern for Queries ‚Äî Encapsulate query criteria in specification objects. Reusable, testable, and keeps repository interface clean.',
        'Avoid Lazy Loading Surprises ‚Äî Be explicit about what\'s loaded. N+1 queries from lazy loading cause performance disasters.',
        'Test with In-Memory Repositories ‚Äî Create in-memory repository implementations for fast unit tests. Only integration test against real database.',
      ],
      dontItems: [
      ],
    },
    agent: {
      avatar: 'ü§ñ',
      name: 'EnterprisePatternArchitect',
      role: '',
      description: 'Expert agent for designing enterprise data access layers, implementing repository patterns, and architecting CQRS/Event Sourcing systems. Specializes in domain-driven design, transaction management, and clean architecture for business applications.',
      capabilities: [
        'Repository pattern implementation',
        'Unit of Work coordination',
        'CQRS read/write separation',
        'Event Sourcing design',
        'Domain model refactoring',
        'Aggregate boundary design',
      ],
      codeFilename: 'repository_pattern.py',
      code: ``,
    },
    relatedPages: [
      { number: '24.4', title: 'Architectural Patterns', description: 'MVC, Clean Architecture, Hexagonal', slug: 'architectural' },
      { number: '24.5', title: 'Concurrency Patterns', description: 'Thread pools, async, reactive patterns', slug: 'concurrency' },
    ],
    prevPage: { title: '24.5 Concurrency Patterns', slug: 'concurrency' },
    nextPage: undefined,
  },
]

registerPages('design-patterns', pages)
export default pages
